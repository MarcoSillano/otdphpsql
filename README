<h1>ODTPHPSQL</h1>
<p> <i>This class is a simple "ODT report system" for mySQL, using '.odt' templates and
producing reports including text, tables, images in almost any format (odt, doc, pdf, txt etc..).</i></p> 
<p> <i> All Reports can be defined or updated at run-time, using only a $templateArray
(stored in a database table) as descriptor of all Fields, Blocks, Images and queries.</i></p>   

<h2>How to create your template</h2>

<p> The Report template file is build using OpenOffice, '.odt', and can contains Field, Block, Image tags
that are repaced from the results of SQL queries to a mySQL database. <p>

<h4>Fields</h4>
<p>If you want to map a single field you can just use #NAME# but you could use anything you like since it's just a search &amp; replace</p>

<ul>
<li>all field-names must be unique and are not case sensitive</li>
<li>the field-names like #img_xxxx# are reserved for images</li>
<li>Fields can be palced in template body, header, footer</li>
</ul>
<h4>Blocks</h4>
Place nested blocks in Template (only body) using '[start blockname]'...'[end blockname]' alone in a template text row:
<pre><code>[start blockname]
   your content,#fields#, image...
[start somenestedblock]
      more content, #fields#, image...
[end somenestedblock]
  ...
[end blockname]
</code></pre>

<ul>
<li>blockname should be unique</li>
<li>blockname has to match \w+ reg ex (a-zA-Z_)</li>
<li>fields mapped in block has to be unique</li>
</ul>

<h4>Images</h4>

<p>Put one or more dummy images in template and near the image, in same block, place a field having a name starting by "img_" (e.g. #img_user# or #img_001").</p>
<p>Limits:
<ul>
<li>only one image per template, per block or per nested block</li>
<li>the image size is fixed in template</li>
</ul>

<h2>How to update the template</h2>

<p>Using only a $templateArray(stored in a database table) as descriptor of all Fields, Blocks, Images and queries:	
<pre><code> $templateArray = array(array("reportId"=>'template4', "block"=>'', "query"=>$query0, "parent"=>''), // block=='': for fields in template [0..n]
array("reportId"=>'template4', "block"=>'base', "query"=>$query1, "parent"=>''), // parente=='': for blocks (1 per block) 
array("reportId"=>'template4', "block"=>'more', "query"=>$query2, "parent"=>'base') ); // for nested blocks (any deep, 1 per nested block)	
</code></pre>
  
 <h4>Fields</h4> 
<ul>
<li>field/values can be pre-defined (like today, user, etc..) see constructor Odtphpsql()</li>
<li>field/values can be assigned as Strings: see assign($field,$value)</li>
<li>field/values can be assigned as Array: see assignArray($fields)</li>
<li>field/values can be read at run-time from a DB, using a query: see assingFieldsSQL($query)</li>
<li>field/values can be defined using one or more records in $templateArray</li>
</ul>
<i>Any query must return a table having some column names equals to field-names in template, only first record is used.</i>

<h4>Blocks and nested blocks</h4> 
<ul>
<li>Blocks can be defined in code: see assignBlock() and assignNestedBlock()</li>
<li>Blocks can be defined using one record per block in $templateArray</li>
</ul>
<p><i>Any query must return a table having some column names equals to all field-names in Block.<br>
The number of found records cantrols the Blocks duplication.</i></p>

<h4>Images</h4> 
<p>Image Fields must have as value the path (relative or absolute) to image file to be used.  The dummy images will be replaced in the report.<p>
<ul>
<li>Use only '/' as path separator also in win.  </li>
<li>It allows some file type change: tested '.jpg' in template and '.png' as replacement.</li>
<li>In case of error, the filed will be replaced by a message, else the field #img_xxx# is deleted.</li>
</ul>
<h4>Queries</h4>

<ul>
<li>Any query can have #field# macros, replaced by current value (in $Odtphp->assigned_field). This is valid also for getArraySQL().</li>
<li>In nested Blocks queries are allowed fields getting value from parent result, like #2# (2 = field position in row, starting from 0)</li>
</ul>

<h2>How to get the report</h2>
<p> The resulting report (.odt) can be saved as file in server and/or sended to client.</p>
<p><i>Using downloadODT() the report can be open in client OpenOffice, so the user can save it
in any supported format ("Save as") or can export it in PDF.</i></p>

<h2>How to use</h2>
<pre><code>
$odtsql = new Odtphpsql($templateFile);        //  constructor
$odtsql->assign("title","My SQL Report");      //  basic field mapping	   
$templateArray = $odtsql->getArraySQL($query_for_template);	 //  gets the descriptors for this template
$odtsql->assignAllSQL($templateArray );       //  sql fields and blocks definitions via templateArray	 
$odtsql->saveODT($outputFile);  //  optional save
$odtsql->downloadODT($name);    //  and/or send to client  

$reportDescription = $odtsql->replaceMacros('My SQL Report for #target# (#today# #now#)');
</code></pre>

<h4>Extras</h4>
<ul>
<li>Anonymizer: The author and data are raised to "odtphp" and the actual data. (Take care to delete all old versions from the template file.)</li>
<li> Template analyse functions: see  getFieldNames(),  getBlockNames(), getNestedBlockNames().</li>
<li> Utility: string macro-replacement using stored field/values: see replaceMacros($string).</li>	
<li> utility: getArraySQL($query) updates the query (if applicable) and returns the query result as rows a array of rows </li>
</ul>
<h4>Final notes</h4>
<p>Odtphpsql->mountNanes and Odtphp->filter() are language specific (italian), but not found more portable solution.</p>	
<p>Uses odtphp.php, a port of djpate phpdocx (good work, see djpate/docxgen ) to odt, and pclzip.lib.php </p>
<p>license GPL </p>
